<script>

    // 使用var 声明变量的问题
    // console.log(a)
    // var a = 1;

    // let的使用，如果使用了let声明的变量，那么这是没有提升
    // let a = 110;
    // console.log(a)  // 如果在前面使用这个变量，那么直接报错

    // 使用let，可以防止重复声明
    // let a = 1;
    // let a = 2;
    // let a = 3;
    // console.log(a)

    // 使用let可以形成一个块级作用域，一个{}就是一个块级作用域
    // 在ES6出现这前，JS中的作用域只有两个：全局作用域，局部作用域
    // 在ES6出现之后，JS中的作用域分成了三个：全局作用域，局部作用域，块级作用域
    // {
    //     let a = 110;
    //     console.log(a)
    // }

    // 看如下代码：
    // let a = 110;
    // {
    //     console.log(a)
    //     // 暂存性死区  如果你在这个块级作用域中使用let声明了一个变量，在块级作用域外面也有一个同名的变量
    //     // 当你要块级作用域中这个变量前面去访问这个变量时，那么它会这样考虑，在块级作用域中
    //     // 已经有了a,只不过你是访问不了的，是因为let声明的变量不能提升
    //     // let a = 666;
    // }

    // 再看一个代码  for循环语句    var i = 0  i是全局变量  
    // for(var i = 0; i<10; i++){
    //     // console.log(i)
    //     setTimeout(function(){
    //         console.log(i)
    //     },1000)
    // }

    // 结果是多少？
    // 在for循环中let i  
    // for(let i = 0; i<10; i++){
    //     setTimeout(function(){
    //         console.log(i)
    //     },1000)
    // }

    // 也就是说，以后，你在使用for循环的时候，不要使用var来声明一个循环变量，
    //  你需要使用let来声明一个循环变量

    // 以后，在使用JS时，能不使用var来声明变量，就不要使用var  

    // 在for循环中循环变量如果使用了let  ，你可以把它当作是，是块级作用域中的变量
    // 也就是说出来{} i就不能生效
    // for(let i = 0; i<10; i++){
    // }
    // console.log(i)


    // 在ES6之前，是没有常量这个说法 
    // 在ES6之后，增加了一个关键字，叫const   是用来声明一个常量
    // const PI = 3.14
    // PI = 666;   如果声明了一个常量，那么这个常量的值，你是不能随便改变
    // console.log(PI)

    // 常量有没有的升的操作   const声明的常量是不能提升
    console.log(NAME)
    const NAME = "wangcai"
    
    // 以后能使用let和const的，就使用let和const，尽量不要使用var
</script>